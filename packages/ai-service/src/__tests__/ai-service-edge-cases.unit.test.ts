import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { AIService } from '../ai-service';
import { OpenAIProvider } from '../providers/openai';
import { ClaudeProvider } from '../providers/claude';
import { AIServiceConfig } from '../types';

/**
 * Unit Tests for AI Service Edge Cases
 * Requirements: 2.1, 2.2, 2.5
 * Test API timeout and failure scenarios
 * Test malformed input handling
 * Test rate limit exceeded scenarios
 * Test circuit breaker activation and recovery
 */

describe('AI Service Edge Cases Unit Tests', () => {
  let aiService: AIService;
  let mockConfig: AIServiceConfig;

  beforeEach(() => {
    mockConfig = {
      providers: {
        openai: {
          apiKey: 'test-openai-key',
          model: 'gpt-4-turbo-preview',
          maxTokens: 2000,
          temperature: 0.3
        },
        claude: {
          apiKey: 'test-claude-key',
          model: 'claude-3-sonnet-20240229',
          maxTokens: 2000,
          temperature: 0.3
        }
      },
      circuitBreaker: {
        failureThreshold: 3,
        resetTimeout: 5000,
        monitoringPeriod: 10000
      },
      rateLimiter: {
        tokensPerMinute: 100,
        requestsPerMinute: 10
      },
      defaultProvider: 'openai',
      fallbackProvider: 'claude'
    };

    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('API Timeout and Failure Scenarios', () => {
    it('should handle API timeout gracefully', async () => {
      // Mock OpenAI provider to timeout
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockImplementation(
        () => new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Request timeout')), 100);
        })
      );

      // Mock Claude provider to succeed
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'fallback code',
        explanation: 'Generated by fallback provider',
        confidence: 0.8,
        tokensUsed: 150,
        model: 'claude-3-sonnet',
        provider: 'claude'
      });

      aiService = new AIService(mockConfig);

      const result = await aiService.generateCode('test prompt');

      expect(result.provider).toBe('claude');
      expect(result.code).toBe('fallback code');
    });

    it('should throw error when all providers fail', async () => {
      // Mock both providers to fail
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('OpenAI API Error')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('Claude API Error')
      );

      aiService = new AIService(mockConfig);

      await expect(aiService.generateCode('test prompt')).rejects.toThrow('OpenAI API Error');
    });

    it('should handle network connectivity issues', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('ENOTFOUND api.openai.com')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'network fallback code',
        confidence: 0.7,
        tokensUsed: 120,
        model: 'claude-3-sonnet',
        provider: 'claude'
      });

      aiService = new AIService(mockConfig);

      const result = await aiService.generateCode('test prompt');
      expect(result.provider).toBe('claude');
    });
  });

  describe('Malformed Input Handling', () => {
    beforeEach(() => {
      // Mock successful responses for these tests
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'generated code',
        confidence: 0.9,
        tokensUsed: 100,
        model: 'gpt-4',
        provider: 'openai'
      });

      aiService = new AIService(mockConfig);
    });

    it('should handle empty prompt', async () => {
      const result = await aiService.generateCode('');
      expect(result.code).toBeDefined();
      expect(result.provider).toBe('openai');
    });

    it('should handle very long prompts', async () => {
      const longPrompt = 'a'.repeat(10000);
      const result = await aiService.generateCode(longPrompt);
      expect(result.code).toBeDefined();
    });

    it('should handle prompts with special characters', async () => {
      const specialPrompt = 'Test with special chars: !@#$%^&*()[]{}|;:,.<>?`~';
      const result = await aiService.generateCode(specialPrompt);
      expect(result.code).toBeDefined();
    });
  });

  describe('Rate Limit Exceeded Scenarios', () => {
    it('should throw rate limit error when token limit exceeded', async () => {
      const limitedConfig = {
        ...mockConfig,
        rateLimiter: {
          tokensPerMinute: 10,
          requestsPerMinute: 100
        }
      };

      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'test code',
        confidence: 0.9,
        tokensUsed: 100,
        model: 'gpt-4',
        provider: 'openai'
      });

      aiService = new AIService(limitedConfig);

      // First request should succeed
      await aiService.generateCode('short prompt');

      // Second request should fail due to token limit
      await expect(
        aiService.generateCode('another prompt', { maxTokens: 50 })
      ).rejects.toThrow(/Token rate limit exceeded/);
    });

    it('should provide accurate remaining limits', async () => {
      const limitedConfig = {
        ...mockConfig,
        rateLimiter: {
          tokensPerMinute: 100,
          requestsPerMinute: 5
        }
      };

      aiService = new AIService(limitedConfig);

      const initialStatus = await aiService.getRateLimitStatus();
      expect(initialStatus?.remainingTokens).toBe(100);
      expect(initialStatus?.remainingRequests).toBe(5);
    });
  });

  describe('Circuit Breaker Activation and Recovery', () => {
    it('should activate circuit breaker after consecutive failures', async () => {
      const cbConfig = {
        ...mockConfig,
        circuitBreaker: {
          failureThreshold: 2,
          resetTimeout: 1000,
          monitoringPeriod: 5000
        }
      };

      // Mock provider to always fail
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('API Error')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('API Error')
      );

      aiService = new AIService(cbConfig);

      // First failure
      await expect(aiService.generateCode('test 1')).rejects.toThrow('API Error');

      // Second failure - should trigger circuit breaker
      await expect(aiService.generateCode('test 2')).rejects.toThrow('API Error');

      // Third attempt - should fail due to circuit breaker
      await expect(aiService.generateCode('test 3')).rejects.toThrow(/Circuit breaker is OPEN/);

      const status = aiService.getProviderStatus();
      expect(status.openai.circuitState).toBe('OPEN');
    });

    it('should reset circuit breakers manually', async () => {
      // Mock provider to fail initially
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('API Error')
      );

      aiService = new AIService(mockConfig);

      // Trigger failures to open circuit breaker
      for (let i = 0; i < 5; i++) {
        try {
          await aiService.generateCode(`test ${i}`);
        } catch (error) {
          // Expected to fail
        }
      }

      // Verify circuit breaker is open
      const statusBefore = aiService.getProviderStatus();
      expect(statusBefore.openai.circuitState).toBe('OPEN');

      // Reset circuit breakers
      aiService.resetCircuitBreakers();

      // Verify circuit breaker is closed
      const statusAfter = aiService.getProviderStatus();
      expect(statusAfter.openai.circuitState).toBe('CLOSED');
    });
  });

  describe('Provider Configuration Edge Cases', () => {
    it('should throw error when no providers configured', () => {
      const emptyConfig: AIServiceConfig = {
        providers: {},
        defaultProvider: 'openai'
      };

      expect(() => new AIService(emptyConfig)).toThrow('At least one AI provider must be configured');
    });

    it('should provide accurate provider status', () => {
      aiService = new AIService(mockConfig);

      const status = aiService.getProviderStatus();

      expect(status).toHaveProperty('openai');
      expect(status).toHaveProperty('claude');
      expect(status.openai.available).toBe(true);
      expect(status.claude.available).toBe(true);
      expect(status.openai.circuitState).toBe('CLOSED');
      expect(status.claude.circuitState).toBe('CLOSED');
    });
  });

  describe('Code Validation Edge Cases', () => {
    beforeEach(() => {
      aiService = new AIService(mockConfig);
    });

    it('should handle validation of empty code', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'validateCode').mockResolvedValue({
        isValid: false,
        errors: ['Code is empty'],
        warnings: [],
        suggestions: ['Add some code']
      });

      const result = await aiService.validateCode('');
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Code is empty');
    });

    it('should handle validation provider failures gracefully', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'validateCode').mockRejectedValue(
        new Error('Validation service unavailable')
      );

      const result = await aiService.validateCode('test code');
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Validation failed: Validation service unavailable');
    });
  });
});